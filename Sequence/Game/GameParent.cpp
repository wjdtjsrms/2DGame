#include "GameLib/GameLib.h"
#include "Sequence\Game\GameParent.h"
#include "Sequence/Game/Loading.h"
#include "Sequence/Game/Clear.h"
#include "Sequence/Game/Menu.h"
#include "Sequence/Game/Play.h"
#include "Sequence/Parent.h"
#include "State.h"
#include "File.h"
#include <sstream>

namespace Sequence {
	namespace Game {

		Parent::Parent(int stageID) :
			mState(0),
			mStageID(stageID),
			mNext(SEQ_NONE),
			mClear(0),
			mLoading(0),
			mMenu(0),
			mPlay(0) {
			mLoading = new Loading();
		}

		Parent::~Parent() {
			SAFE_DELETE(mState);
			SAFE_DELETE(mClear);
			SAFE_DELETE(mLoading);
			SAFE_DELETE(mMenu);
			SAFE_DELETE(mPlay);
		}

		void Parent::update(GrandParent* parent) {
			// 객체가 생성되었을때만 실행
			if (mClear) {
				mClear->update(this);
			}
			else if (mLoading) {
				mLoading->update(this);
			}
			else if (mMenu) {
				mMenu->update(this);
			}
			else if (mPlay) {
				mPlay->update(this);
			}
			else {
				HALT("BABO!"); // 유효하지 않은 값
			}

			switch (mNext) {
			case SEQ_STAGE_SELECT:
				parent->moveTo(GrandParent::SEQ_STAGE_SELECT); // 상위 Sequence 객체 호출
				break;
			case SEQ_TITLE:
				parent->moveTo(GrandParent::SEQ_TITLE); // 상위 Sequence 객체 호출
				break;
			case SEQ_PLAY:
				SAFE_DELETE(mLoading);
				SAFE_DELETE(mMenu);
				mPlay = new Game::Play();
				break;
			case SEQ_CLEAR:
				SAFE_DELETE(mPlay);
				mClear = new Game::Clear();
				break;
			case SEQ_MENU:
				SAFE_DELETE(mPlay);
				mMenu = new Game::Menu();
				break;
			}


			mNext = SEQ_NONE; // 현재 상태가 끝나지 않았다.
		}

		void Parent::startLoading() {
			std::ostringstream oss;
			oss << "data/stageData/" << mStageID << ".txt";
			File file(oss.str().c_str()); //스트링을 const char*형으로 반환
			mState = new State(file.data(), file.size());
		}

		// 자식 객체들이 이 멤버 변수를 변경한다.
		void Parent::moveTo(SeqID next) {
			mNext = next;
		}

		// 그리기 기능이 있는 state 객체를 반환한다.
		State* Parent::state(){
			return mState;
		}

	}

	
}